

// ifeq
{{#ifeq: 01 | 1 | equal | not equal}} → equal
{{#ifeq: 0 | -0 | equal | not equal}} → equal
{{#ifeq: 1e3 | 1000 | equal | not equal}} → equal
{{#ifeq: {{#expr:10^3}} | 1000 | equal | not equal}} → equal

Otherwise the comparison is made as text; this comparison is case sensitive:

{{#ifeq: foo | bar | equal | not equal}} → not equal
{{#ifeq: foo | Foo | equal | not equal}} → not equal
{{#ifeq: foo | foo | equal | not equal}} → equal
{{#ifeq: "01" | "1" | equal | not equal}} → not equal  (compare to similar example above, without the quotes)
{{#ifeq: 10^3 | 1000 | equal | not equal}} → not equal













// iferror
This function takes an input string and returns one of two results; the function evaluates to true if the input string contains an HTML object with class="error", as generated by other parser functions such as #expr, #time and #rel2abs, template errors such as loops and recursions, and other "failsoft" parser errors.

    {{#iferror: test string | value if error | value if correct }}

One or both of the return strings can be omitted. If the correct string is omitted, the test string is returned if it is not erroneous. If the error string is also omitted, an empty string is returned on an error:

    {{#iferror: {{#expr: 1 + 2 }} | error | correct }} → correct
    {{#iferror: {{#expr: 1 + X }} | error | correct }} → error
    {{#iferror: {{#expr: 1 + 2 }} | error }} → 3
    {{#iferror: {{#expr: 1 + X }} | error }} → error
    {{#iferror: {{#expr: 1 + 2 }} }} → 3
    {{#iferror: {{#expr: 1 + X }} }} → ‌
    {{#iferror: {{#expr: . }} | error | correct }} → correct
    {{#iferror: <strong class="error">a</strong> | error | correct }} → error














// ifexpr
    This function evaluates a mathematical expression and returns one of two strings depending on the boolean value of the result:

        {{#ifexpr: expression | value if true | value if false }}

    The expression input is evaluated exactly as for #expr above, with the same operators being available. The output is then evaluated as a boolean expression.

    An empty input expression evaluates to false:

        {{#ifexpr: | yes | no}} → no    // FIXME: bug

    As mentioned above, zero evaluates to false and any nonzero value evaluates to true, so this function is equivalent to one using #ifeq and #expr only:

        {{#ifeq: {{#expr: expression }} | 0 | value if false | value if true }}

    except for an empty or wrong input expression (an error message is treated as an empty string; it is not equal to zero, so we get value if true).

        {{#ifexpr: = | yes | no }} → Expression error: Unexpected = operator.

    comparing

        {{#ifeq: {{#expr: = }} | 0 | no | yes }} → yes

    Either or both the return values may be omitted; no output is given when the appropriate branch is left empty:

        {{#ifexpr: 1 > 0 | yes }} → yes
        {{#ifexpr: 1 < 0 | yes }} →
        {{#ifexpr: 0 = 0 | yes }} → yes
        {{#ifexpr: 1 > 0 | | no}} →
        {{#ifexpr: 1 < 0 | | no}} → no
        {{#ifexpr: 1 > 0 }} →


















// expr
When evaluating using boolean algebra, zero evaluates to false, and any nonzero value, positive or negative, evaluates to true:

    {{#expr: 1 and -1 }} → 1
    {{#expr: 1 and 0 }} → 0
    {{#expr: 1 or -1 }} → 1
    {{#expr: -1 or 0 }} → 1
    {{#expr: 0 or 0 }} → 0

An empty input expression returns an empty string. Invalid expressions return one of several error messages, which can be caught using the #iferror function:

    {{#expr: }} →
    {{#expr: 1+ }} → Expression error: Missing operand for +.
    {{#expr: 1 = }} → Expression error: Missing operand for =.
    {{#expr: 1 foo 2 }} → Expression error: Unrecognized word "foo".

The order of addition and subtraction operands before or after a number is meaningful and may be treated as a positive or negative value instead of as an operand with an erroneous input:

    {{#expr: +1 }} → 1
    {{#expr: -1 }} → -1
    {{#expr: + 1 }} → 1
    {{#expr: - 1 }} → -1

Note, if using the output of magic words, you must raw-format them in order to remove commas and translate the numerals. For example, {{NUMBEROFUSERS}} results in 17,174,696, where we want 17174696, which can be obtained using {{formatnum:{{NUMBEROFUSERS}}|R}}. This is especially important in some languages, where numerals are translated. For example, in Bengali, {{NUMBEROFUSERS}} produces ৩০,০৬১.

    {{#expr:{{NUMBEROFUSERS}}+100}} → Expression error: Unrecognized punctuation character ",".
    {{#expr:{{formatnum:{{NUMBEROFUSERS}}|R}}+100}} → 17174796

Warning Warning: 	The operator mod gives wrong results for some values of the second argument:

    {{#expr: 123 mod (2^64-1)}} → Division by zero. (produces an empty string; should be 123)

If you want to do calculations based on dates (ex. test whether current date and time is after some other date and time), first convert the time to number of seconds after January 1, 1970 using {{#time: xNU }}, then you can simply add and subtract dates as numbers.
Rounding

Rounds off the number on the left to a multiple of 1/10 raised to a power, with the exponent equal to the truncated value of the number given on the right.

To round up or down use unary ceil or floor respectively.
Test case 	Result 	Method of rounding
{{#expr: 1/3 round 5 }} 	0.33333 	Final digit is < 5, so no apparent rounding occurs
{{#expr: 1/6 round 5 }} 	0.16667 	Final digit is ≥ 5, so it is rounded up
{{#expr: 8.99999/9 round 5 }} 	1 	Again, the result is rounded up on the last digit, which results in additional rounding
{{#expr: 1234.5678 round -2 }} 	1200 	Rounded to nearest 100 because negative values round to the left of the decimal point
{{#expr: 1234.5678 round 2 }} 	1234.57 	Rounded to nearest 100th because positive values round to the right of the decimal point
{{#expr: 1234.5678 round 2.3 }} 	1234.57 	Decimals in the rounding index make no difference in the rounded result
{{#expr: trunc 1234.5678 }} 	1234 	Decimal portion truncated (chopped off)
Rounding to the nearest integer
{{#expr: 1/3 round 0 }} 	0 	Down to the nearest integer, which is zero
{{#expr: 1/2 round 0 }} 	1 	Up to the nearest integer, which is one
{{#expr: 3/4 round 0 }} 	1 	Up to the nearest integer, which is one
{{#expr: -1/3 round 0 }} 	-0 	Up to the nearest integer, which is zero
{{#expr: -1/2 round 0 }} 	-1 	Down to the nearest integer, which is negative one
{{#expr: -3/4 round 0 }} 	-1 	Down to the nearest integer, which is negative one
Rounding up or down with ceil and floor
{{#expr: ceil(1/3) }} 	1 	Up to the next larger integer, which is one
{{#expr: floor(1/3) }} 	0 	Down to the next smaller integer, which is zero
{{#expr: ceil(-1/3) }} 	-0 	Up to the next larger integer, which is zero
{{#expr: floor(-1/3) }} 	-1 	Down to the next smaller integer, which is negative one
{{#expr: ceil 1/3 }} 	0.33333333333333 	Not rounded, since 1 already is an integer
Warning Warning: 	Interpreted as (ceil 1)/3, not ceil(1/3), as you might expect


Strings

Expressions only work with number-like values, they cannot compare strings or characters. #ifeq can be used instead.

    {{#expr: "a" = "a" }} → Expression error: Unrecognized punctuation character """.
    {{#expr: a = a }} → Expression error: Unrecognized word "a".









#ifexist
    {{#ifexist: Help:Extension:ParserFunctions | exists | doesn't exist }} → exists
    {{#ifexist: XXHelp:Extension:ParserFunctionsXX | exists | doesn't exist }} → doesn't exist

The function evaluates to true for system messages that have been customized, and for special pages that are defined by the software.

    {{#ifexist: Special:Watchlist | exists | doesn't exist }} → exists
    {{#ifexist: Special:CheckUser | exists | doesn't exist }} → exists (because the Checkuser extension is installed on this wiki)
    {{#ifexist: MediaWiki:Copyright | exists | doesn't exist }} → exists (because MediaWiki:Copyright has been customized)

If a page checks a target using #ifexist:, then that page will appear in the Special:WhatLinksHere list for the target page. So if the code {{#ifexist:Foo }} were included live on this page (Help:Extension:ParserFunctions), Special:WhatLinksHere/Foo will list Help:Extension:ParserFunctions.

On wikis using a shared media repository, #ifexist: can be used to check if a file has been uploaded to the repository but not to the wiki itself:

    {{#ifexist: File:Example.png | exists | doesn't exist }} → doesn't exist
    {{#ifexist: Image:Example.png | exists | doesn't exist }} → doesn't exist
    {{#ifexist: Media:Example.png | exists | doesn't exist }} → exists

If a local description page has been created for the file, the result is exists for all of the above.

#ifexist: does not work with interwiki links.










#switch


    {{#switch: baz | foo = Foo | baz = Baz | Bar }} → Baz
    {{#switch: foo | foo = Foo | baz = Baz | Bar }} → Foo
    {{#switch: zzz | foo = Foo | baz = Baz | Bar }} → Bar

#switch with partial transclusion tags can effect a configuration file that enables an editor unfamiliar with template coding to view and edit configurable elements.
Default

The default result is returned if no case string matches the comparison string:

    {{#switch: test | foo = Foo | baz = Baz | Bar }} → Bar

In this syntax, the default result must be the last parameter and must not contain a raw equals sign.

    {{#switch: test | Bar | foo = Foo | baz = Baz }} →
    {{#switch: test | foo = Foo | baz = Baz | B=ar }} →

    Default results declared in this way may be placed anywhere within the function:

    {{#switch: test | foo = Foo | #default = Bar | baz = Baz }} → Bar

If the default parameter is omitted and no match is made, no result is returned:

    {{#switch: test | foo = Foo | baz = Baz }} →

Grouping results

It is possible to have 'fall through' values, where several case strings return the same result string. This minimizes duplication.

{{#switch: comparison string
 | case1 = result1
 | case2
 | case3
 | case4 = result234
 | case5 = result5
 | case6
 | case7 = result67
 | #default = default result
}}

Here cases 2, 3 and 4 all return result234; cases 6 and 7 both return result67
Comparison behavior

As with #ifeq, the comparison is made numerically if both the comparison string and the case string being tested are numeric; or as a case-sensitive string otherwise:

    {{#switch: 0 + 1 | 1 = one | 2 = two | three}} → three
    {{#switch: {{#expr: 0 + 1}} | 1 = one | 2 = two | three}} → one

    {{#switch: a | a = A | b = B | C}} → A
    {{#switch: A | a = A | b = B | C}} → C

A case string may be empty:

    {{#switch: | = Nothing | foo = Foo | Something }} → Nothing

Once a match is found, subsequent cases are ignored:

    {{#switch: b | f = Foo | b = Bar | b = Baz | }} → Bar

//FIXME:
    Raw equal signs

  "Case" strings cannot contain raw equals signs. To work around this, create a template {{=}} containing a single equals sign: =, or replace equals sign with html code &#61;.

  Example:

      {{#switch: 1=2
       | 1=2 = raw
       | 1<nowiki>=</nowiki>2 = nowiki
       | 1{{=}}2 = template
       | default
      }} → template


      {{#switch: 1=2
       | 1&#61;2 = html
       | default
      }} → html
